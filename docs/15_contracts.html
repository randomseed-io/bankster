<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Bankster Contracts</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="css/randomseed.css" /></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Bankster</span> <span class="project-version">2.0.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="10_introduction.html"><div class="inner"><span>Introduction</span></div></a></li><li class="depth-1  current"><a href="15_contracts.html"><div class="inner"><span>Bankster Contracts</span></div></a></li><li class="depth-1 "><a href="20_data_structures.html"><div class="inner"><span>Data Structures</span></div></a></li><li class="depth-1 "><a href="30_currency-kinds.html"><div class="inner"><span>Currency kinds</span></div></a></li><li class="depth-1 "><a href="32_currency_traits.html"><div class="inner"><span>Currency traits</span></div></a></li><li class="depth-1 "><a href="50_example_config.html"><div class="inner"><span>Example EDN config</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>randomseed</span></div></div></li><li class="depth-3"><a href="io.randomseed.bankster.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bankster</span></div></a></li><li class="depth-4 branch"><a href="io.randomseed.bankster.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-4 branch"><a href="io.randomseed.bankster.currency.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>currency</span></div></a></li><li class="depth-4 branch"><a href="io.randomseed.bankster.init.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>init</span></div></a></li><li class="depth-4 branch"><a href="io.randomseed.bankster.jsr-354.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jsr-354</span></div></a></li><li class="depth-4"><a href="io.randomseed.bankster.money.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>money</span></div></a></li><li class="depth-5 branch"><a href="io.randomseed.bankster.money.inter-ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>inter-ops</span></div></a></li><li class="depth-5"><a href="io.randomseed.bankster.money.ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ops</span></div></a></li><li class="depth-4 branch"><a href="io.randomseed.bankster.registry.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>registry</span></div></a></li><li class="depth-4 branch"><a href="io.randomseed.bankster.scale.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scale</span></div></a></li><li class="depth-4"><a href="io.randomseed.bankster.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-5 branch"><a href="io.randomseed.bankster.util.fs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fs</span></div></a></li><li class="depth-5 branch"><a href="io.randomseed.bankster.util.importer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>importer</span></div></a></li><li class="depth-5"><a href="io.randomseed.bankster.util.map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>map</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#bankster-contracts" id="bankster-contracts"></a>Bankster Contracts</h1>
<p>This document describes practical contracts (what is guaranteed, what is “soft” vs “strict”, how the default registry is chosen, when exceptions are thrown, how the protocols behave) for Bankster’s core axis: <code>Currency</code>, <code>Money</code>, <code>Registry</code> records and the <code>Monetary</code>, <code>Scalable</code> and <code>Accountable</code> protocols.</p>
<p>This is not an API reference (it does not list all arities), but a guide to behavior.</p>
<h2><a href="#1-foundations-model-and-global-rules" id="1-foundations-model-and-global-rules"></a>1. Foundations (model and global rules)</h2>
<ul>
<li>Bankster models money as data: <code>Money = (Currency, BigDecimal amount)</code>.</li>
<li><code>Registry</code> is the source of truth for currencies (resolving by ID/code/numeric-id, localization, country relations).</li>
<li>Computations are based on <code>BigDecimal</code> (no silent <code>double</code>).</li>
<li>The “soft” API returns <code>nil</code> when no match is found; the “strict” API throws <code>ExceptionInfo</code>.</li>
<li>Loading <code>io.randomseed.bankster.currency</code> auto-initializes the global registry from <code>config.edn</code> by default. To disable this side effect (and initialize explicitly), bind <code>io.randomseed.bankster/*initialize-registry*</code> to <code>false</code> around <code>require</code>.</li>
<li>Namespace <code>io.randomseed.bankster.jsr-354</code> is an experimental, work-in-progress Clojure semantic bridge inspired by JSR-354 (JavaMoney). It is not a Java implementation/interface of the standard. The goal is to progressively cover more of JSR-354 semantics in future Bankster releases; until then, treat this namespace as unstable.</li>
<li><code>:weight</code> is a <em>registry</em> attribute used to resolve conflicts when resolving by code and numeric ID (in <code>:cur-code-&gt;curs</code> and <code>:cur-nr-&gt;curs</code>). Weight is stored in the registry base map <code>:cur-id-&gt;weight</code> (exported as top-level <code>:weights</code> in EDN). Currency instances stored in registries also carry the weight in metadata as an optimization. Weight is ignored by <code>Currency</code>/<code>Money</code> equality and arithmetic.</li>
</ul>
<h3><a href="#11-terminology" id="11-terminology"></a>1.1 Terminology</h3>
<ul>
<li>Currency ID: a keyword, e.g. <code>:EUR</code> or <code>:crypto/ETH</code> (namespaced).</li>
<li>Currency code: an <em>unqualified</em> keyword, e.g. <code>:EUR</code>, <code>:ETH</code> (from <code>:crypto/ETH</code> you get <code>:ETH</code>).</li>
<li>Domain: a classification of a “currency world” (e.g. <code>:ISO-4217</code>, <code>:CRYPTO</code>). For namespaced currencies it is derived from the namespace (upper-case).</li>
<li>Kind: a case-sensitive keyword classifying what a currency <em>is</em>. It may be namespaced (e.g. <code>:iso/fiat</code>, <code>:virtual/token</code>).</li>
<li>Traits: advisory tags/features associated with a currency (stored in a registry), independent from currency identity and <code>Money</code> semantics.</li>
<li>Scale:</li>
<li>for a currency: nominal number of decimal places,</li>
<li>for <code>Money</code>: the scale of the amount (<code>BigDecimal</code> scale).</li>
<li>Auto-scaled currency: a currency with an “automatic” scale (no fixed nominal scale; the amount carries scale).</li>
<li>Weight: an integer where <em>lower weight wins</em> when resolving code / numeric-ID conflicts in a registry.</li>
</ul>
<h3><a href="#12-error-model" id="12-error-model"></a>1.2 Error model</h3>
<ul>
<li>Contract violations (wrong arity/typing combination, mismatched currencies, missing currency in registry, missing rounding-mode, etc.) are signaled via <code>clojure.lang.ExceptionInfo</code> (<code>ex-info</code>).</li>
<li>In <code>ex-data</code> you will typically find keys like <code>:registry</code>, <code>:currency</code>, <code>:value</code>, <code>:op</code>, and/or domain-specific keys (<code>:augend</code>, <code>:addend</code>, <code>:minuend</code>, <code>:subtrahend</code>, <code>:dividend</code>, <code>:divisor</code>).</li>
<li>When an error originates from <code>BigDecimal</code> arithmetic (Java <code>ArithmeticException</code>), Bankster rethrows it as <code>ExceptionInfo</code> and marks it in <code>ex-data</code> with:</li>
<li><code>:arithmetic-exception true</code>,</li>
<li><code>:arithmetic-exception/cause</code> (the original <code>ArithmeticException</code>, also used as the exception cause).</li>
</ul>
<h2><a href="#2-records-core-data" id="2-records-core-data"></a>2. Records (core data)</h2>
<h3><a href="#21-iorandomseedbankstercurrency" id="21-iorandomseedbankstercurrency"></a>2.1 <code>io.randomseed.bankster/Currency</code></h3>
<p>Fields:</p>
<ul>
<li><code>:id</code> (keyword) - unique currency identifier within a registry.</li>
<li><code>:numeric</code> (long) - numeric id (e.g. ISO 4217); absence is represented by a sentinel (<code>no-numeric-id</code>).</li>
<li><code>:scale</code> (int) - nominal currency scale; auto-scale is represented by a sentinel (<code>auto-scaled</code>).</li>
<li><code>:kind</code> (keyword or nil) - classification (case-sensitive; may be namespaced, e.g. <code>:iso/fiat</code>, <code>:virtual/token</code>).</li>
<li><code>:domain</code> (keyword or nil) - domain (e.g. <code>:ISO-4217</code>, <code>:CRYPTO</code>).</li>
</ul>
<p>Non-inherent attribute:</p>
<ul>
<li><code>:weight</code> (int) - weight used to resolve conflicts when resolving by code and/or numeric ID (lower wins).</li>
<li>Source of truth: registry base map <code>:cur-id-&gt;weight</code> (<code>:weights</code> in EDN config).</li>
<li>Registry <code>Currency</code> instances carry weight in metadata for hot paths (bucket sorting), accessible via <code>currency/weight</code>.</li>
<li>In EDN config <code>:weight</code> may be omitted (implicit 0).</li>
<li>Branch-oriented export (<code>importer/registry-&gt;map</code>) emits weights under top-level <code>:weights</code> (presence is meaningful; explicit <code>0</code> is supported).</li>
<li>Currency-oriented export embeds per-currency <code>:weight</code> into <code>:currencies</code> while keeping orphaned <code>:weights</code> entries.</li>
</ul>
<p>Contracts:</p>
<ul>
<li><code>Currency</code> is “data first”: field values are explicit; there are no hidden side effects.</li>
<li><code>(.toString Currency)</code> returns the <em>code</em> (i.e. <code>(name :id)</code>), not the full ID. Do not rely on <code>toString</code> in logs. For stable identification use <code>currency/id</code> (keyword) or <code>currency/to-id-str</code> (string without keyword interning).</li>
<li><code>Currency</code> values may carry an extension map (extra keys) because they are Clojure records. Bankster itself keeps core semantics in record fields and treats extension keys as non-semantic metadata.</li>
<li>When loading currencies from EDN configuration, extra keys present in currency maps are ignored by default.</li>
<li>To allow selected extra keys to be preserved on <code>Currency</code> objects, use <code>:propagate-keys</code> (global allowlist) and/or per-currency <code>:propagate-keys</code> (override). Keys reserved by core currency construction and configuration pre-population (e.g. <code>:id</code>, <code>:kind</code>, <code>:scale</code>, <code>:numeric</code>, <code>:domain</code>, <code>:weight</code>, <code>:countries</code>, <code>:localized</code>, <code>:traits</code>, and the directive <code>:propagate-keys</code>) are never propagated.</li>
</ul>
<h3><a href="#22-iorandomseedbankstermoney" id="22-iorandomseedbankstermoney"></a>2.2 <code>io.randomseed.bankster/Money</code></h3>
<p>Fields:</p>
<ul>
<li><code>:currency</code> - a <code>Currency</code> object.</li>
<li><code>:amount</code> - <code>java.math.BigDecimal</code>.</li>
</ul>
<p>Contracts:</p>
<ul>
<li><code>Money</code> always carries a <code>BigDecimal</code> (inputs are coerced through the <code>scale</code> layer).</li>
<li><code>(.toString Money)</code> returns <code>"AMOUNT CODE"</code> (code comes from <code>Currency/toString</code>).</li>
<li>The amount scale in <code>Money</code> is part of the data (it may differ from the currency’s nominal scale). This is supported, but has consequences (see <code>money/rescaled?</code>, <code>money/rescale</code>, <code>money/strip</code>).</li>
</ul>
<h3><a href="#23-iorandomseedbanksterregistry" id="23-iorandomseedbanksterregistry"></a>2.3 <code>io.randomseed.bankster/Registry</code></h3>
<p>The registry is a record with indices (maps), including:</p>
<ul>
<li><code>:cur-id-&gt;cur</code> - currency ID -&gt; <code>Currency</code> (canonical entry).</li>
<li><code>:cur-code-&gt;curs</code> - currency code -&gt; a set of currencies (sorted, “weighted”).</li>
<li><code>:cur-nr-&gt;cur</code> - numeric-id -&gt; <code>Currency</code>.</li>
<li><code>:cur-nr-&gt;curs</code> - numeric-id -&gt; a set of currencies (sorted, “weighted”).</li>
<li><code>:ctr-id-&gt;cur</code> - country ID -&gt; <code>Currency</code>.</li>
<li><code>:cur-id-&gt;ctr-ids</code> - currency ID -&gt; a set of country IDs.</li>
<li><code>:cur-id-&gt;localized</code> - currency ID -&gt; localization/properties map.</li>
<li><code>:cur-id-&gt;traits</code> - currency ID -&gt; traits (a set/vector of keywords; advisory).</li>
<li><code>:cur-id-&gt;weight</code> - currency ID -&gt; int weight (conflict resolution).</li>
<li><code>:hierarchies</code> - a <code>CurrencyHierarchies</code> record holding per-axis hierarchies (usually at least <code>:domain</code> and <code>:kind</code>, optionally <code>:traits</code> and/or custom axes).</li>
<li><code>:version</code> - string (timestamp-style).</li>
<li><code>:ext</code> - extra data (map).</li>
</ul>
<p>Contracts:</p>
<ul>
<li>The global registry lives in <code>io.randomseed.bankster.registry/R</code> (Atom).</li>
<li>In many operations, “default registry” means: the dynamic <code>registry/*default*</code> (when bound), otherwise the global <code>registry/R</code>.</li>
<li>Registry hierarchies are used by higher-level predicates that rely on <code>isa?</code> (e.g. <code>currency/of-domain?</code>, <code>currency/of-kind?</code>, <code>currency/of-trait?</code>). Custom axes may be introduced by consumers (stored under additional keys in <code>:hierarchies</code>).</li>
<li>When multiple currencies share the same numeric ID, the registry keeps them all in <code>:cur-nr-&gt;curs</code> and picks a canonical one for <code>:cur-nr-&gt;cur</code> using weight (lower wins).</li>
</ul>
<h2><a href="#3-protocols" id="3-protocols"></a>3. Protocols</h2>
<h3><a href="#31-iorandomseedbankstercurrencymonetary" id="31-iorandomseedbankstercurrencymonetary"></a>3.1 <code>io.randomseed.bankster.currency/Monetary</code></h3>
<p>Monetary is the “coercion + currency resolution” layer.</p>
<p>General rule:</p>
<ul>
<li><code>to-*</code> methods are cheap and registry-free (may return <code>nil</code>).</li>
<li><code>resolve</code>/<code>resolve-all</code> consult a registry and are “soft” (may return <code>nil</code>).</li>
<li><code>unit</code>/<code>of-id</code> are “strict” (throw when the currency is missing from the registry), with an explicit convention <code>registry=nil</code> for already constructed <code>Currency</code> values (see below).</li>
</ul>
<p>Key methods and their contracts:</p>
<ul>
<li><code>to-id</code> -&gt; keyword:</li>
<li>registry-free,</li>
<li>may intern keywords (e.g. from a string) - do not use on untrusted input.</li>
<li><code>to-code</code> -&gt; keyword:</li>
<li>registry-free,</li>
<li>returns an unqualified code.</li>
<li><code>to-id-str</code> / <code>to-code-str</code> -&gt; String:</li>
<li>registry-free,</li>
<li>should not intern keywords (safer for untrusted input),</li>
<li>canonicalization: upper-case name, namespace preserved (for ID).</li>
<li><code>to-numeric-id</code> -&gt; long/nil:</li>
<li>registry-free hint (for objects that carry a numeric id).</li>
<li><code>to-currency</code> -&gt; Currency/nil:</li>
<li>registry-free; may create an ad-hoc <code>Currency</code> (e.g. from a map).</li>
<li><code>to-map</code> -&gt; map/nil:</li>
<li>registry-free; the map may be partial.</li>
<li><code>definitive?</code> -&gt; boolean:</li>
<li>whether the representation carries enough information to make meaningful negative property checks (e.g. “definitely not ISO”).</li>
<li><code>resolve</code> -&gt; Currency/nil:</li>
<li>soft: returns <code>nil</code> when it cannot be resolved.</li>
<li>when <code>registry</code> is <code>nil</code>, uses the default registry.</li>
<li><code>resolve-all</code> -&gt; set/nil:</li>
<li>soft; returns a set of matches or <code>nil</code>.</li>
<li><code>id</code> -&gt; keyword:</li>
<li>unary:
<ul>
<li>advisory / soft: returns what it can infer locally,</li>
<li>may consult the default registry to disambiguate unqualified currency codes (e.g. <code>:BTC</code> -&gt; <code>:crypto/BTC</code> when such currency exists),</li>
<li>does not throw on missing currencies (note: numeric IDs are different - see below).</li>
</ul>
</li>
<li>binary: <code>registry=nil</code> means “do not consult a registry” (return local ID/coercion).</li>
<li>binary: when a registry is actually consulted, missing currency -&gt; exception. For already constructed <code>Currency</code> values the registry is ignored and <code>.id</code> is returned.</li>
<li>binary: <code>registry</code> should be a <code>Registry</code> (or <code>nil</code> as above). The boolean sentinel <code>true</code> works only syntactically via <code>(registry/get true)</code> (macro-level); passing <code>true</code> as a runtime value is not supported.</li>
<li>note: for numeric IDs (numbers), <code>id</code> always consults a registry and throws when the mapping is missing.</li>
<li><code>of-id</code> -&gt; Currency:</li>
<li>strict: missing currency -&gt; exception,</li>
<li>when the argument is a <code>Currency</code>: <code>registry=nil</code> means “return as-is”.</li>
<li><code>unit</code> -&gt; Currency:</li>
<li>strict: missing currency -&gt; exception,</li>
<li>when the argument is a <code>Currency</code>: <code>registry=nil</code> means “return as-is”,</li>
<li>for maps: maps are treated as masks/constraints (match by key presence), and when multiple matches exist, the best match is selected by weight (lower wins).</li>
<li><code>defined?</code> -&gt; boolean:</li>
<li>existence of a currency in a registry (by ID/numeric/code); this is a “does anything exist” check, without validating full field-level consistency.</li>
<li><code>present?</code> -&gt; boolean:</li>
<li>checks whether the representation is consistent with the entry in the registry (field match).</li>
</ul>
<p>Soft helpers:</p>
<ul>
<li><code>currency/attempt</code> and <code>currency/attempt*</code>:</li>
<li>soft coercion: returns a <code>Currency</code> or <code>nil</code>, does not throw.</li>
<li>preferred in predicates and “try” paths.</li>
</ul>
<h3><a href="#32-iorandomseedbanksterscalescalable" id="32-iorandomseedbanksterscalescalable"></a>3.2 <code>io.randomseed.bankster.scale/Scalable</code></h3>
<p>Scalable is the “what is scale” + “how to safely produce BigDecimal” layer.</p>
<p>Methods:</p>
<ul>
<li><code>scalable?</code> -&gt; boolean: can this value be coerced to a scalable value?</li>
<li><code>applied?</code> -&gt; boolean: does the value already carry scale information (e.g. <code>BigDecimal</code>, <code>Money</code>, <code>Currency</code>)?</li>
<li><code>of</code> -&gt; long: scale (for <code>Money</code> it’s the amount scale; for <code>Currency</code> it’s the currency scale).</li>
<li><code>apply</code> -&gt; scaled value:</li>
<li>for numbers: returns a <code>BigDecimal</code>,</li>
<li>for <code>Money</code>: may rescale the amount; unary <code>apply</code> reapplies the currency’s nominal scale (when the currency is not auto-scaled).</li>
<li>for <code>Currency</code>: returns a <code>Currency</code> with updated <code>:scale</code>.</li>
<li><code>amount</code> -&gt; BigDecimal:</li>
<li>for <code>Money</code>: returns the amount,</li>
<li>for <code>Currency</code>: returns <code>nil</code> (a currency does not have an “amount”),</li>
<li>for numbers: returns a <code>BigDecimal</code> (after coercion).</li>
</ul>
<p>Dynamic vars and rounding:</p>
<ul>
<li><code>scale/*rounding-mode*</code>:</li>
<li>default rounding mode used by scaling operations when rounding is needed.</li>
<li><code>scale/*each*</code>:</li>
<li>when true, some operations (e.g. multi-arg division in money) rescale after each step.</li>
<li><code>scale/with-rounding</code>:</li>
<li>binds <code>*rounding-mode*</code> and sets a thread-local fast path for rounding-mode lookups (performance).</li>
<li><code>scale/with-rescaling</code>:</li>
<li>binds <code>*each*</code> + <code>*rounding-mode*</code> and sets a thread-local fast path for rounding-mode lookups (performance).</li>
</ul>
<p>Recommendation:</p>
<ul>
<li>Prefer using <code>scale/with-rounding</code> / <code>scale/with-rescaling</code> (or the aliases in <code>io.randomseed.bankster.money</code>) instead of a raw <code>binding</code> on <code>scale/*rounding-mode*</code> in performance-sensitive code. Plain <code>binding</code> remains supported, but it does not use the fast path and may be noticeably slower in tight numeric loops.</li>
</ul>
<h3><a href="#33-iorandomseedbankstermoneyaccountable" id="33-iorandomseedbankstermoneyaccountable"></a>3.3 <code>io.randomseed.bankster.money/Accountable</code></h3>
<p>Accountable is the “what can become Money” + “how to convert Money across currencies/registries” layer.</p>
<p>Methods:</p>
<ul>
<li><code>value</code> -&gt; Money/nil:</li>
<li>builds a <code>Money</code> from numbers/strings/currency identifiers, etc.,</li>
<li>when the amount is <code>nil</code> it typically returns <code>nil</code>,</li>
<li>when currency is missing and cannot be inferred, it throws,</li>
<li>a rounding mode is required when coercion/scaling needs rounding and there is no explicit rounding mode and <code>scale/*rounding-mode*</code> is not set.</li>
<li><code>cast</code> -&gt; Money:</li>
<li>changes currency (with rescaling/rounding preserved),</li>
<li>if you only need to ensure the currency comes from a given registry, prefer <code>money/of-registry</code>.</li>
</ul>
<h2><a href="#4-public-function-families-practical-classification" id="4-public-function-families-practical-classification"></a>4. Public function families (practical classification)</h2>
<h3><a href="#41-registry-api-iorandomseedbanksterregistry" id="41-registry-api-iorandomseedbanksterregistry"></a>4.1 Registry API (<code>io.randomseed.bankster.registry</code>)</h3>
<p>Creation and global state:</p>
<ul>
<li><code>registry/new</code>, <code>registry/new-registry</code> - create a new registry.</li>
<li><code>registry/R</code> - Atom holding the global registry.</li>
<li><code>registry/get</code> - returns a registry:</li>
<li><code>(registry/get)</code> uses the default registry (dynamic or global),</li>
<li><code>(registry/get registry)</code> prefers the provided registry unless it is <code>nil</code> or <code>false</code>,</li>
<li><code>(registry/get true)</code> works as a syntactic sentinel (macro-level): use the default registry.</li>
<li><code>registry/state</code> - <code>@R</code> (global).</li>
<li><code>registry/set!</code> - sets the global registry.</li>
<li><code>registry/update</code>, <code>registry/update!</code> - functional / global update.</li>
<li><code>registry/with</code> - lexically binds the default registry (<code>registry/*default*</code>).</li>
<li><code>registry/hierarchies</code>, <code>registry/hierarchy</code> - access registry hierarchies.</li>
<li><code>registry/hierarchy-derive</code>, <code>registry/hierarchy-derive!</code> - update a selected hierarchy axis in a registry (pure / global mutation).</li>
</ul>
<p>Read-only indices:</p>
<ul>
<li><code>registry/currency-id-&gt;currency</code>, <code>registry/currency-code-&gt;currencies</code>, <code>registry/currency-nr-&gt;currency</code>, etc.</li>
<li><code>registry/currency-id-&gt;traits</code> - access per-currency traits.</li>
<li><code>registry/version</code>, <code>registry/ext</code>.</li>
</ul>
<p>Diagnostics:</p>
<ul>
<li><code>registry/*warn-on-inconsistency*</code>, <code>registry/*warnings-logger*</code>, <code>registry/inconsistency-warning</code>.</li>
</ul>
<h3><a href="#42-currency-api-iorandomseedbankstercurrency" id="42-currency-api-iorandomseedbankstercurrency"></a>4.2 Currency API (<code>io.randomseed.bankster.currency</code>)</h3>
<p>Construction:</p>
<ul>
<li><code>currency/new-currency</code>, <code>currency/new</code>, <code>currency/map-&gt;new</code>:</li>
<li>canonicalize IDs (upper-case name; namespace preserved, except <code>ISO-4217</code> which is stripped),</li>
<li>may infer <code>:domain</code> as <code>:ISO-4217</code> under typical conditions,</li>
<li><code>:weight</code> defaults to 0.</li>
</ul>
<p>Default currency / registry:</p>
<ul>
<li><code>currency/*default*</code>, <code>currency/set-default!</code>, <code>currency/unset-default!</code>.</li>
<li><code>currency/set-default-registry!</code>, <code>currency/config-&gt;registry</code>.</li>
</ul>
<p>Resolution and coercion:</p>
<ul>
<li><code>currency/of</code> (macro) - convenient currency retrieval (from registry or ad-hoc for maps).</li>
<li><code>currency/unit</code>, <code>currency/of-id</code> - strict; throw when currency is missing from the registry.</li>
<li><code>currency/resolve</code>, <code>currency/resolve-all</code> - soft; return <code>nil</code> when nothing matches.</li>
<li><code>currency/attempt</code>, <code>currency/attempt*</code>, <code>currency/with-attempt</code> - soft helpers.</li>
</ul>
<p>Registry operations (mutate a registry value functionally; no side effects unless you use <code>!</code> variants):</p>
<ul>
<li><code>currency/register</code>, <code>currency/unregister</code>, <code>currency/update</code> (+ <code>!</code> variants on the global registry).</li>
<li><code>currency/add-countries</code>, <code>currency/remove-countries</code> (+ <code>!</code>).</li>
<li><code>currency/add-localized-properties</code>, <code>currency/remove-localized-properties</code> (+ <code>!</code>).</li>
<li><code>currency/add-weighted-code</code> (associate code with currency; conflicts resolved by weight).</li>
<li><code>currency/set-weight</code>, <code>currency/clear-weight</code> (+ <code>!</code>) - narrow API to mutate the registry weight base (<code>:cur-id-&gt;weight</code>) while keeping weighted indices and canonical numeric resolution synchronized.</li>
<li><code>currency/set-traits</code>, <code>currency/add-traits</code>, <code>currency/remove-traits</code> (+ <code>!</code>) - narrow API to mutate the registry traits base (<code>:cur-id-&gt;traits</code>).</li>
</ul>
<p>Predicates and classification:</p>
<ul>
<li><code>currency/currency?</code>, <code>currency/possible?</code>, <code>currency/definitive?</code>, <code>currency/defined?</code>, <code>currency/present?</code>.</li>
<li><code>currency/iso?</code>, <code>currency/iso-strict?</code>, <code>currency/iso-legacy?</code>, <code>currency/crypto?</code>, <code>currency/fiat?</code>, etc.</li>
<li><code>currency/of-domain?</code> - hierarchy-aware domain predicate (uses <code>registry/:hierarchies</code> when present).</li>
<li><code>currency/of-kind?</code> - hierarchy-aware kind predicate (uses <code>registry/:hierarchies</code> when present).</li>
<li><code>currency/has-trait?</code> (exact membership) and <code>currency/of-trait?</code> (hierarchy-aware) - trait predicates backed by <code>registry/:cur-id-&gt;traits</code> and optionally <code>registry/:hierarchies/:traits</code>.</li>
<li><code>currency/null?</code>, <code>currency/none?</code> - nil/empty/null-currency helpers.</li>
<li><code>currency/same-ids?</code> - identity comparison by ID (soft, symmetric).</li>
</ul>
<p>Properties and localization:</p>
<ul>
<li><code>currency/id</code>, <code>currency/code</code>, <code>currency/ns-code</code>, <code>currency/nr</code>, <code>currency/sc</code>, <code>currency/domain</code>, <code>currency/kind</code>, <code>currency/weight</code>.</li>
<li><code>currency/info</code> - full currency info map (fields + registry metadata).</li>
<li><code>currency/countries</code>, <code>currency/localized-properties</code>, <code>currency/localized-property</code>.</li>
<li><code>currency/symbol</code>, <code>currency/display-name</code> (+ <code>*-native</code>).</li>
<li><code>currency/formatter</code>, <code>currency/formatter-extended</code>.</li>
</ul>
<p>Tagged literals:</p>
<ul>
<li><code>#currency ...</code> (via <code>currency/code-literal</code> / <code>currency/data-literal</code>).</li>
</ul>
<h3><a href="#43-money-api-iorandomseedbankstermoney" id="43-money-api-iorandomseedbankstermoney"></a>4.3 Money API (<code>io.randomseed.bankster.money</code>)</h3>
<p>Creation / parsing:</p>
<ul>
<li><code>money/value</code> (Accountable) - the primary constructor function.</li>
<li><code>money/of</code>, <code>money/of-major</code>, <code>money/of-minor</code> (macro) - ergonomic creation.</li>
<li><code>money/major-value</code>, <code>money/minor-value</code> - creation via major/minor parts.</li>
<li><code>money/parse</code>, <code>money/parse-major</code>, <code>money/parse-minor</code> - internal parsers (public, but mostly low-level).</li>
<li><code>money/of-registry</code> - forces the currency in Money to come from the given registry (and aligns scale).</li>
</ul>
<p>Properties and inspection:</p>
<ul>
<li><code>money/amount</code>, <code>money/currency</code>, <code>money/stripped-amount</code>, <code>money/unparse</code>.</li>
<li><code>money/money?</code>, <code>money/rescaled?</code>, <code>money/auto-scaled?</code>.</li>
</ul>
<p>Comparisons and predicates:</p>
<ul>
<li><code>money/compare</code>, <code>money/compare-amounts</code> (strict: require matching currency; <code>nil</code> is comparable and is the “lowest”).</li>
<li><code>money/eq?</code>, <code>money/eq-am?</code> (<code>==</code>), <code>money/ne?</code>, <code>money/ne-am?</code> (<code>not==</code>).</li>
<li><code>money/gt?</code>, <code>money/ge?</code>, <code>money/lt?</code>, <code>money/le?</code>.</li>
<li><code>money/is-pos?</code>, <code>money/is-neg?</code>, <code>money/is-zero?</code>, <code>money/is-pos-or-zero?</code>, <code>money/is-neg-or-zero?</code> (+ aliases <code>pos?</code>, <code>neg?</code>, <code>zero?</code>).</li>
</ul>
<p>Arithmetic (general rule: currencies must be “the same currency”, but weight is ignored):</p>
<ul>
<li><code>money/add</code> (<code>+</code>), <code>money/sub</code> (<code>-</code>):</li>
<li>accept <code>Money</code> and require matching currency,</li>
<li>do not allow adding/subtracting plain numbers to/from <code>Money</code>.</li>
<li><code>money/mul</code> (<code>*</code>):</li>
<li>allows <code>Money</code> * numbers,</li>
<li>supports at most one <code>Money</code> argument in the whole expression; otherwise throws <code>ExceptionInfo</code>.</li>
<li><code>money/div</code> (<code>/</code>):</li>
<li><code>Money / number</code> -&gt; Money,</li>
<li><code>Money / Money</code> (same currency) -&gt; <code>BigDecimal</code>,</li>
<li><code>number / Money</code> -&gt; exception.</li>
<li>unary <code>money/div</code> works like <code>clojure.core//</code> for numbers, but throws for <code>Money</code> (because it would be equivalent to <code>number / Money</code>).</li>
<li><code>money/rem</code>:</li>
<li>analogous to <code>div</code>: for <code>Money/Money</code> the result is <code>BigDecimal</code>, for <code>Money/number</code> the result is <code>Money</code>.</li>
</ul>
<p>Scaling / rounding:</p>
<ul>
<li><code>money/scale</code>, <code>money/rescale</code>, <code>money/round</code>, <code>money/round-to</code>, <code>money/strip</code> (use consciously).</li>
<li>Context macros: <code>money/with-rounding</code>, <code>money/with-rescaling</code> (aliases to <code>scale/...</code>).</li>
</ul>
<p>Allocation:</p>
<ul>
<li><code>money/allocate</code>:</li>
<li>splits the amount into parts according to integer-like ratios,</li>
<li>the sum of parts equals the original exactly (sum-preserving),</li>
<li>the remainder is distributed deterministically left-to-right.</li>
<li><code>money/distribute</code>:</li>
<li><code>allocate</code> with ratios <code>(repeat n 1)</code>.</li>
</ul>
<p>Formatting:</p>
<ul>
<li><code>money/format</code>, <code>money/format-with</code> (use formatters from <code>currency</code>).</li>
</ul>
<p>Tagged literals / readers:</p>
<ul>
<li><code>#money ...</code> (via <code>money/code-literal</code> / <code>money/data-literal</code> + <code>*-crypto</code> variants).</li>
<li><code>money/data-readers</code>, <code>money/code-readers</code>.</li>
</ul>
<h3><a href="#44-inter-op-layers-operators" id="44-inter-op-layers-operators"></a>4.4 Inter-op layers (operators)</h3>
<ul>
<li><code>io.randomseed.bankster.money.ops</code>:</li>
<li>operator aliases (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, etc.) that always mean Money semantics.</li>
<li><code>io.randomseed.bankster.money.inter-ops</code>:</li>
<li>if there is <em>no</em> <code>Money</code> argument, behaves 1:1 like <code>clojure.core</code>,</li>
<li>if there is any <code>Money</code> argument, it “taints” the operation and switches to Bankster semantics.</li>
</ul>
<h2><a href="#5-recommendations-and-pitfalls-practical" id="5-recommendations-and-pitfalls-practical"></a>5. Recommendations and pitfalls (practical)</h2>
<ul>
<li>Do not identify currencies by <code>toString</code>. Use <code>currency/id</code> or <code>currency/to-id-str</code>.</li>
<li>Avoid <code>clojure.core/=</code> for <code>Money</code> comparisons (it uses record/map equality, compares <code>BigDecimal</code> values using Clojure numeric equality (scale-insensitive), and may reflect non-semantic differences like currency extension keys). Prefer <code>money/eq?</code> (or <code>money/=</code>) / <code>money/eq-am?</code> (<code>money/==</code>), or the inter-op layer <code>io.randomseed.bankster.money.inter-ops/=</code> for mixed numeric expressions.</li>
<li>For untrusted input (e.g. from an API) prefer <code>to-id-str</code> / <code>to-code-str</code> and validate, instead of calling <code>keyword</code> (interning).</li>
<li>Be explicit about rounding: set <code>scale/*rounding-mode*</code> via <code>scale/with-rounding</code> or pass rounding-mode explicitly.</li>
<li>Beware Clojure floating-point literals (precision). For money, prefer:
<ul>
<li>BigDecimal literals with <code>M</code>, or</li>
<li>strings (parsed into BigDecimal).</li>
</ul>
</li>
<li>Auto-scaled currencies carry scale in the amount. This can be convenient, but requires care when interoperating with fixed-scale systems.</li>
</ul>
</div></div></div></body></html>